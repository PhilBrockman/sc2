{"ast":null,"code":"import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport * as React from 'react';\nimport { forwardRef, useRef, useCallback, useEffect } from 'react';\nconst $node = Symbol.for('Animated:node');\n\nconst isAnimated = value => !!value && value[$node] === value;\n\nconst getAnimated = owner => owner && owner[$node];\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\n\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this.done = true;\n    this.durationProgress = 0;\n    this._value = _value;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]));\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, dep => addFluidObserver(dep, observer));\n\n      if (lastObserver) {\n        each(lastObserver.deps, dep => removeFluidObserver(dep, lastObserver));\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer = observerRef.current;\n      each(observer.deps, dep => removeFluidObserver(dep, observer));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return React.createElement(Component, _extends({}, usedProps, {\n      ref: ref\n    }));\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _extends({}, props, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\n\nconst createHost = (components, {\n  applyAnimatedValues: _applyAnimatedValues = () => false,\n  createAnimatedStyle: _createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps: _getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues: _applyAnimatedValues,\n    createAnimatedStyle: _createAnimatedStyle,\n    getComponentProps: _getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"sources":["/Users/philbrockman/coding/sc2/node_modules/@react-spring/animated/dist/react-spring-animated.esm.js"],"names":["defineHidden","is","createInterpolator","eachProp","hasFluidValue","getFluidValue","each","isAnimatedString","useForceUpdate","useLayoutEffect","addFluidObserver","removeFluidObserver","raf","useOnce","React","forwardRef","useRef","useCallback","useEffect","$node","Symbol","for","isAnimated","value","getAnimated","owner","setAnimated","node","getPayload","Animated","constructor","payload","AnimatedValue","_value","done","durationProgress","num","lastPosition","create","getValue","setValue","step","Math","round","reset","elapsedTime","lastVelocity","v0","AnimatedString","_string","_toString","output","str","goal","TreeContext","dependencies","AnimatedObject","source","animated","values","key","_makePayload","Set","_addToPayload","Array","from","add","AnimatedArray","map","length","some","i","makeAnimated","nodeType","getAnimatedType","parentNode","arr","_extends","Object","assign","target","arguments","prototype","hasOwnProperty","call","apply","withAnimated","Component","host","hasInstance","fun","isReactComponent","givenProps","givenRef","instanceRef","ref","current","updateRef","props","deps","getAnimatedState","forceUpdate","callback","instance","didUpdate","applyAnimatedValues","observer","PropsObserver","observerRef","lastObserver","dep","cancel","update","usedProps","getComponentProps","createElement","eventObserved","event","type","write","style","createAnimatedStyle","cacheKey","createHost","components","_applyAnimatedValues","_createAnimatedStyle","_getComponentProps","hostConfig","displayName","getDisplayName","arg","name"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,EAAvB,EAA2BC,kBAA3B,EAA+CC,QAA/C,EAAyDC,aAAzD,EAAwEC,aAAxE,EAAuFC,IAAvF,EAA6FC,gBAA7F,EAA+GC,cAA/G,EAA+HC,eAA/H,EAAgJC,gBAAhJ,EAAkKC,mBAAlK,EAAuLC,GAAvL,EAA4LC,OAA5L,QAA2M,sBAA3M;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,EAAqBC,MAArB,EAA6BC,WAA7B,EAA0CC,SAA1C,QAA2D,OAA3D;AAEA,MAAMC,KAAK,GAAGC,MAAM,CAACC,GAAP,CAAW,eAAX,CAAd;;AACA,MAAMC,UAAU,GAAGC,KAAK,IAAI,CAAC,CAACA,KAAF,IAAWA,KAAK,CAACJ,KAAD,CAAL,KAAiBI,KAAxD;;AACA,MAAMC,WAAW,GAAGC,KAAK,IAAIA,KAAK,IAAIA,KAAK,CAACN,KAAD,CAA3C;;AACA,MAAMO,WAAW,GAAG,CAACD,KAAD,EAAQE,IAAR,KAAiB3B,YAAY,CAACyB,KAAD,EAAQN,KAAR,EAAeQ,IAAf,CAAjD;;AACA,MAAMC,UAAU,GAAGH,KAAK,IAAIA,KAAK,IAAIA,KAAK,CAACN,KAAD,CAAd,IAAyBM,KAAK,CAACN,KAAD,CAAL,CAAaS,UAAb,EAArD;;AACA,MAAMC,QAAN,CAAe;AACbC,EAAAA,WAAW,GAAG;AACZJ,IAAAA,WAAW,CAAC,IAAD,EAAO,IAAP,CAAX;AACD;;AAEDE,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKG,OAAL,IAAgB,EAAvB;AACD;;AAPY;;AAWf,MAAMC,aAAN,SAA4BH,QAA5B,CAAqC;AACnCC,EAAAA,WAAW,CAACG,MAAD,EAAS;AAClB;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKF,MAAL,GAAcA,MAAd;;AAEA,QAAIhC,EAAE,CAACmC,GAAH,CAAO,KAAKH,MAAZ,CAAJ,EAAyB;AACvB,WAAKI,YAAL,GAAoB,KAAKJ,MAAzB;AACD;AACF;;AAEY,SAANK,MAAM,CAACf,KAAD,EAAQ;AACnB,WAAO,IAAIS,aAAJ,CAAkBT,KAAlB,CAAP;AACD;;AAEDK,EAAAA,UAAU,GAAG;AACX,WAAO,CAAC,IAAD,CAAP;AACD;;AAEDW,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKN,MAAZ;AACD;;AAEDO,EAAAA,QAAQ,CAACjB,KAAD,EAAQkB,IAAR,EAAc;AACpB,QAAIxC,EAAE,CAACmC,GAAH,CAAOb,KAAP,CAAJ,EAAmB;AACjB,WAAKc,YAAL,GAAoBd,KAApB;;AAEA,UAAIkB,IAAJ,EAAU;AACRlB,QAAAA,KAAK,GAAGmB,IAAI,CAACC,KAAL,CAAWpB,KAAK,GAAGkB,IAAnB,IAA2BA,IAAnC;;AAEA,YAAI,KAAKP,IAAT,EAAe;AACb,eAAKG,YAAL,GAAoBd,KAApB;AACD;AACF;AACF;;AAED,QAAI,KAAKU,MAAL,KAAgBV,KAApB,EAA2B;AACzB,aAAO,KAAP;AACD;;AAED,SAAKU,MAAL,GAAcV,KAAd;AACA,WAAO,IAAP;AACD;;AAEDqB,EAAAA,KAAK,GAAG;AACN,UAAM;AACJV,MAAAA;AADI,QAEF,IAFJ;AAGA,SAAKA,IAAL,GAAY,KAAZ;;AAEA,QAAIjC,EAAE,CAACmC,GAAH,CAAO,KAAKH,MAAZ,CAAJ,EAAyB;AACvB,WAAKY,WAAL,GAAmB,CAAnB;AACA,WAAKV,gBAAL,GAAwB,CAAxB;AACA,WAAKE,YAAL,GAAoB,KAAKJ,MAAzB;AACA,UAAIC,IAAJ,EAAU,KAAKY,YAAL,GAAoB,IAApB;AACV,WAAKC,EAAL,GAAU,IAAV;AACD;AACF;;AA1DkC;;AA8DrC,MAAMC,cAAN,SAA6BhB,aAA7B,CAA2C;AACzCF,EAAAA,WAAW,CAACP,KAAD,EAAQ;AACjB,UAAM,CAAN;AACA,SAAK0B,OAAL,GAAe,IAAf;AACA,SAAKC,SAAL,GAAiBhD,kBAAkB,CAAC;AAClCiD,MAAAA,MAAM,EAAE,CAAC5B,KAAD,EAAQA,KAAR;AAD0B,KAAD,CAAnC;AAGD;;AAEY,SAANe,MAAM,CAACf,KAAD,EAAQ;AACnB,WAAO,IAAIyB,cAAJ,CAAmBzB,KAAnB,CAAP;AACD;;AAEDgB,EAAAA,QAAQ,GAAG;AACT,QAAIhB,KAAK,GAAG,KAAK0B,OAAjB;AACA,WAAO1B,KAAK,IAAI,IAAT,GAAgB,KAAK0B,OAAL,GAAe,KAAKC,SAAL,CAAe,KAAKjB,MAApB,CAA/B,GAA6DV,KAApE;AACD;;AAEDiB,EAAAA,QAAQ,CAACjB,KAAD,EAAQ;AACd,QAAItB,EAAE,CAACmD,GAAH,CAAO7B,KAAP,CAAJ,EAAmB;AACjB,UAAIA,KAAK,IAAI,KAAK0B,OAAlB,EAA2B;AACzB,eAAO,KAAP;AACD;;AAED,WAAKA,OAAL,GAAe1B,KAAf;AACA,WAAKU,MAAL,GAAc,CAAd;AACD,KAPD,MAOO,IAAI,MAAMO,QAAN,CAAejB,KAAf,CAAJ,EAA2B;AAChC,WAAK0B,OAAL,GAAe,IAAf;AACD,KAFM,MAEA;AACL,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD;;AAEDL,EAAAA,KAAK,CAACS,IAAD,EAAO;AACV,QAAIA,IAAJ,EAAU;AACR,WAAKH,SAAL,GAAiBhD,kBAAkB,CAAC;AAClCiD,QAAAA,MAAM,EAAE,CAAC,KAAKZ,QAAL,EAAD,EAAkBc,IAAlB;AAD0B,OAAD,CAAnC;AAGD;;AAED,SAAKpB,MAAL,GAAc,CAAd;AACA,UAAMW,KAAN;AACD;;AA5CwC;;AAgD3C,MAAMU,WAAW,GAAG;AAClBC,EAAAA,YAAY,EAAE;AADI,CAApB;;AAIA,MAAMC,cAAN,SAA6B3B,QAA7B,CAAsC;AACpCC,EAAAA,WAAW,CAAC2B,MAAD,EAAS;AAClB;AACA,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKjB,QAAL,CAAciB,MAAd;AACD;;AAEDlB,EAAAA,QAAQ,CAACmB,QAAD,EAAW;AACjB,UAAMC,MAAM,GAAG,EAAf;AACAxD,IAAAA,QAAQ,CAAC,KAAKsD,MAAN,EAAc,CAACA,MAAD,EAASG,GAAT,KAAiB;AACrC,UAAItC,UAAU,CAACmC,MAAD,CAAd,EAAwB;AACtBE,QAAAA,MAAM,CAACC,GAAD,CAAN,GAAcH,MAAM,CAAClB,QAAP,CAAgBmB,QAAhB,CAAd;AACD,OAFD,MAEO,IAAItD,aAAa,CAACqD,MAAD,CAAjB,EAA2B;AAChCE,QAAAA,MAAM,CAACC,GAAD,CAAN,GAAcvD,aAAa,CAACoD,MAAD,CAA3B;AACD,OAFM,MAEA,IAAI,CAACC,QAAL,EAAe;AACpBC,QAAAA,MAAM,CAACC,GAAD,CAAN,GAAcH,MAAd;AACD;AACF,KARO,CAAR;AASA,WAAOE,MAAP;AACD;;AAEDnB,EAAAA,QAAQ,CAACiB,MAAD,EAAS;AACf,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAK1B,OAAL,GAAe,KAAK8B,YAAL,CAAkBJ,MAAlB,CAAf;AACD;;AAEDb,EAAAA,KAAK,GAAG;AACN,QAAI,KAAKb,OAAT,EAAkB;AAChBzB,MAAAA,IAAI,CAAC,KAAKyB,OAAN,EAAeJ,IAAI,IAAIA,IAAI,CAACiB,KAAL,EAAvB,CAAJ;AACD;AACF;;AAEDiB,EAAAA,YAAY,CAACJ,MAAD,EAAS;AACnB,QAAIA,MAAJ,EAAY;AACV,YAAM1B,OAAO,GAAG,IAAI+B,GAAJ,EAAhB;AACA3D,MAAAA,QAAQ,CAACsD,MAAD,EAAS,KAAKM,aAAd,EAA6BhC,OAA7B,CAAR;AACA,aAAOiC,KAAK,CAACC,IAAN,CAAWlC,OAAX,CAAP;AACD;AACF;;AAEDgC,EAAAA,aAAa,CAACN,MAAD,EAAS;AACpB,QAAIH,WAAW,CAACC,YAAZ,IAA4BnD,aAAa,CAACqD,MAAD,CAA7C,EAAuD;AACrDH,MAAAA,WAAW,CAACC,YAAZ,CAAyBW,GAAzB,CAA6BT,MAA7B;AACD;;AAED,UAAM1B,OAAO,GAAGH,UAAU,CAAC6B,MAAD,CAA1B;;AAEA,QAAI1B,OAAJ,EAAa;AACXzB,MAAAA,IAAI,CAACyB,OAAD,EAAUJ,IAAI,IAAI,KAAKuC,GAAL,CAASvC,IAAT,CAAlB,CAAJ;AACD;AACF;;AAlDmC;;AAsDtC,MAAMwC,aAAN,SAA4BX,cAA5B,CAA2C;AACzC1B,EAAAA,WAAW,CAAC2B,MAAD,EAAS;AAClB,UAAMA,MAAN;AACD;;AAEY,SAANnB,MAAM,CAACmB,MAAD,EAAS;AACpB,WAAO,IAAIU,aAAJ,CAAkBV,MAAlB,CAAP;AACD;;AAEDlB,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKkB,MAAL,CAAYW,GAAZ,CAAgBzC,IAAI,IAAIA,IAAI,CAACY,QAAL,EAAxB,CAAP;AACD;;AAEDC,EAAAA,QAAQ,CAACiB,MAAD,EAAS;AACf,UAAM1B,OAAO,GAAG,KAAKH,UAAL,EAAhB;;AAEA,QAAI6B,MAAM,CAACY,MAAP,IAAiBtC,OAAO,CAACsC,MAA7B,EAAqC;AACnC,aAAOtC,OAAO,CAACuC,IAAR,CAAa,CAAC3C,IAAD,EAAO4C,CAAP,KAAa5C,IAAI,CAACa,QAAL,CAAciB,MAAM,CAACc,CAAD,CAApB,CAA1B,CAAP;AACD;;AAED,UAAM/B,QAAN,CAAeiB,MAAM,CAACW,GAAP,CAAWI,YAAX,CAAf;AACA,WAAO,IAAP;AACD;;AAtBwC;;AA0B3C,SAASA,YAAT,CAAsBjD,KAAtB,EAA6B;AAC3B,QAAMkD,QAAQ,GAAGlE,gBAAgB,CAACgB,KAAD,CAAhB,GAA0ByB,cAA1B,GAA2ChB,aAA5D;AACA,SAAOyC,QAAQ,CAACnC,MAAT,CAAgBf,KAAhB,CAAP;AACD;;AAED,SAASmD,eAAT,CAAyBnD,KAAzB,EAAgC;AAC9B,QAAMoD,UAAU,GAAGnD,WAAW,CAACD,KAAD,CAA9B;AACA,SAAOoD,UAAU,GAAGA,UAAU,CAAC7C,WAAd,GAA4B7B,EAAE,CAAC2E,GAAH,CAAOrD,KAAP,IAAgB4C,aAAhB,GAAgC5D,gBAAgB,CAACgB,KAAD,CAAhB,GAA0ByB,cAA1B,GAA2ChB,aAAxH;AACD;;AAED,SAAS6C,QAAT,GAAoB;AAClBA,EAAAA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAC5C,SAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,SAAS,CAACZ,MAA9B,EAAsCE,CAAC,EAAvC,EAA2C;AACzC,UAAId,MAAM,GAAGwB,SAAS,CAACV,CAAD,CAAtB;;AAEA,WAAK,IAAIX,GAAT,IAAgBH,MAAhB,EAAwB;AACtB,YAAIqB,MAAM,CAACI,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC3B,MAArC,EAA6CG,GAA7C,CAAJ,EAAuD;AACrDoB,UAAAA,MAAM,CAACpB,GAAD,CAAN,GAAcH,MAAM,CAACG,GAAD,CAApB;AACD;AACF;AACF;;AAED,WAAOoB,MAAP;AACD,GAZD;;AAcA,SAAOH,QAAQ,CAACQ,KAAT,CAAe,IAAf,EAAqBJ,SAArB,CAAP;AACD;;AAED,MAAMK,YAAY,GAAG,CAACC,SAAD,EAAYC,IAAZ,KAAqB;AACxC,QAAMC,WAAW,GAAG,CAACxF,EAAE,CAACyF,GAAH,CAAOH,SAAP,CAAD,IAAsBA,SAAS,CAACL,SAAV,IAAuBK,SAAS,CAACL,SAAV,CAAoBS,gBAArF;AACA,SAAO5E,UAAU,CAAC,CAAC6E,UAAD,EAAaC,QAAb,KAA0B;AAC1C,UAAMC,WAAW,GAAG9E,MAAM,CAAC,IAAD,CAA1B;AACA,UAAM+E,GAAG,GAAGN,WAAW,IAAIxE,WAAW,CAACM,KAAK,IAAI;AAC9CuE,MAAAA,WAAW,CAACE,OAAZ,GAAsBC,SAAS,CAACJ,QAAD,EAAWtE,KAAX,CAA/B;AACD,KAFqC,EAEnC,CAACsE,QAAD,CAFmC,CAAtC;AAGA,UAAM,CAACK,KAAD,EAAQC,IAAR,IAAgBC,gBAAgB,CAACR,UAAD,EAAaJ,IAAb,CAAtC;AACA,UAAMa,WAAW,GAAG7F,cAAc,EAAlC;;AAEA,UAAM8F,QAAQ,GAAG,MAAM;AACrB,YAAMC,QAAQ,GAAGT,WAAW,CAACE,OAA7B;;AAEA,UAAIP,WAAW,IAAI,CAACc,QAApB,EAA8B;AAC5B;AACD;;AAED,YAAMC,SAAS,GAAGD,QAAQ,GAAGf,IAAI,CAACiB,mBAAL,CAAyBF,QAAzB,EAAmCL,KAAK,CAAC3D,QAAN,CAAe,IAAf,CAAnC,CAAH,GAA8D,KAAxF;;AAEA,UAAIiE,SAAS,KAAK,KAAlB,EAAyB;AACvBH,QAAAA,WAAW;AACZ;AACF,KAZD;;AAcA,UAAMK,QAAQ,GAAG,IAAIC,aAAJ,CAAkBL,QAAlB,EAA4BH,IAA5B,CAAjB;AACA,UAAMS,WAAW,GAAG5F,MAAM,EAA1B;AACAP,IAAAA,eAAe,CAAC,MAAM;AACpB,YAAMoG,YAAY,GAAGD,WAAW,CAACZ,OAAjC;AACAY,MAAAA,WAAW,CAACZ,OAAZ,GAAsBU,QAAtB;AACApG,MAAAA,IAAI,CAAC6F,IAAD,EAAOW,GAAG,IAAIpG,gBAAgB,CAACoG,GAAD,EAAMJ,QAAN,CAA9B,CAAJ;;AAEA,UAAIG,YAAJ,EAAkB;AAChBvG,QAAAA,IAAI,CAACuG,YAAY,CAACV,IAAd,EAAoBW,GAAG,IAAInG,mBAAmB,CAACmG,GAAD,EAAMD,YAAN,CAA9C,CAAJ;AACAjG,QAAAA,GAAG,CAACmG,MAAJ,CAAWF,YAAY,CAACG,MAAxB;AACD;AACF,KATc,CAAf;AAUA9F,IAAAA,SAAS,CAACoF,QAAD,EAAW,EAAX,CAAT;AACAzF,IAAAA,OAAO,CAAC,MAAM,MAAM;AAClB,YAAM6F,QAAQ,GAAGE,WAAW,CAACZ,OAA7B;AACA1F,MAAAA,IAAI,CAACoG,QAAQ,CAACP,IAAV,EAAgBW,GAAG,IAAInG,mBAAmB,CAACmG,GAAD,EAAMJ,QAAN,CAA1C,CAAJ;AACD,KAHM,CAAP;AAIA,UAAMO,SAAS,GAAGzB,IAAI,CAAC0B,iBAAL,CAAuBhB,KAAK,CAAC3D,QAAN,EAAvB,CAAlB;AACA,WAAOzB,KAAK,CAACqG,aAAN,CAAoB5B,SAApB,EAA+BV,QAAQ,CAAC,EAAD,EAAKoC,SAAL,EAAgB;AAC5DlB,MAAAA,GAAG,EAAEA;AADuD,KAAhB,CAAvC,CAAP;AAGD,GA3CgB,CAAjB;AA4CD,CA9CD;;AAgDA,MAAMY,aAAN,CAAoB;AAClB7E,EAAAA,WAAW,CAACkF,MAAD,EAASb,IAAT,EAAe;AACxB,SAAKa,MAAL,GAAcA,MAAd;AACA,SAAKb,IAAL,GAAYA,IAAZ;AACD;;AAEDiB,EAAAA,aAAa,CAACC,KAAD,EAAQ;AACnB,QAAIA,KAAK,CAACC,IAAN,IAAc,QAAlB,EAA4B;AAC1B1G,MAAAA,GAAG,CAAC2G,KAAJ,CAAU,KAAKP,MAAf;AACD;AACF;;AAViB;;AAcpB,SAASZ,gBAAT,CAA0BF,KAA1B,EAAiCV,IAAjC,EAAuC;AACrC,QAAMjC,YAAY,GAAG,IAAIO,GAAJ,EAArB;AACAR,EAAAA,WAAW,CAACC,YAAZ,GAA2BA,YAA3B;AACA,MAAI2C,KAAK,CAACsB,KAAV,EAAiBtB,KAAK,GAAGrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;AAC3CsB,IAAAA,KAAK,EAAEhC,IAAI,CAACiC,mBAAL,CAAyBvB,KAAK,CAACsB,KAA/B;AADoC,GAAZ,CAAhB;AAGjBtB,EAAAA,KAAK,GAAG,IAAI1C,cAAJ,CAAmB0C,KAAnB,CAAR;AACA5C,EAAAA,WAAW,CAACC,YAAZ,GAA2B,IAA3B;AACA,SAAO,CAAC2C,KAAD,EAAQ3C,YAAR,CAAP;AACD;;AAED,SAAS0C,SAAT,CAAmBF,GAAnB,EAAwBxE,KAAxB,EAA+B;AAC7B,MAAIwE,GAAJ,EAAS;AACP,QAAI9F,EAAE,CAACyF,GAAH,CAAOK,GAAP,CAAJ,EAAiBA,GAAG,CAACxE,KAAD,CAAH,CAAjB,KAAiCwE,GAAG,CAACC,OAAJ,GAAczE,KAAd;AAClC;;AAED,SAAOA,KAAP;AACD;;AAED,MAAMmG,QAAQ,GAAGtG,MAAM,CAACC,GAAP,CAAW,mBAAX,CAAjB;;AACA,MAAMsG,UAAU,GAAG,CAACC,UAAD,EAAa;AAC9BnB,EAAAA,mBAAmB,EAAEoB,oBAAoB,GAAG,MAAM,KADpB;AAE9BJ,EAAAA,mBAAmB,EAAEK,oBAAoB,GAAGN,KAAK,IAAI,IAAIhE,cAAJ,CAAmBgE,KAAnB,CAFvB;AAG9BN,EAAAA,iBAAiB,EAAEa,kBAAkB,GAAG7B,KAAK,IAAIA;AAHnB,IAI5B,EAJe,KAIR;AACT,QAAM8B,UAAU,GAAG;AACjBvB,IAAAA,mBAAmB,EAAEoB,oBADJ;AAEjBJ,IAAAA,mBAAmB,EAAEK,oBAFJ;AAGjBZ,IAAAA,iBAAiB,EAAEa;AAHF,GAAnB;;AAMA,QAAMrE,QAAQ,GAAG6B,SAAS,IAAI;AAC5B,UAAM0C,WAAW,GAAGC,cAAc,CAAC3C,SAAD,CAAd,IAA6B,WAAjD;;AAEA,QAAItF,EAAE,CAACmD,GAAH,CAAOmC,SAAP,CAAJ,EAAuB;AACrBA,MAAAA,SAAS,GAAG7B,QAAQ,CAAC6B,SAAD,CAAR,KAAwB7B,QAAQ,CAAC6B,SAAD,CAAR,GAAsBD,YAAY,CAACC,SAAD,EAAYyC,UAAZ,CAA1D,CAAZ;AACD,KAFD,MAEO;AACLzC,MAAAA,SAAS,GAAGA,SAAS,CAACmC,QAAD,CAAT,KAAwBnC,SAAS,CAACmC,QAAD,CAAT,GAAsBpC,YAAY,CAACC,SAAD,EAAYyC,UAAZ,CAA1D,CAAZ;AACD;;AAEDzC,IAAAA,SAAS,CAAC0C,WAAV,GAAyB,YAAWA,WAAY,GAAhD;AACA,WAAO1C,SAAP;AACD,GAXD;;AAaApF,EAAAA,QAAQ,CAACyH,UAAD,EAAa,CAACrC,SAAD,EAAY3B,GAAZ,KAAoB;AACvC,QAAI3D,EAAE,CAAC2E,GAAH,CAAOgD,UAAP,CAAJ,EAAwB;AACtBhE,MAAAA,GAAG,GAAGsE,cAAc,CAAC3C,SAAD,CAApB;AACD;;AAED7B,IAAAA,QAAQ,CAACE,GAAD,CAAR,GAAgBF,QAAQ,CAAC6B,SAAD,CAAxB;AACD,GANO,CAAR;AAOA,SAAO;AACL7B,IAAAA;AADK,GAAP;AAGD,CAlCD;;AAoCA,MAAMwE,cAAc,GAAGC,GAAG,IAAIlI,EAAE,CAACmD,GAAH,CAAO+E,GAAP,IAAcA,GAAd,GAAoBA,GAAG,IAAIlI,EAAE,CAACmD,GAAH,CAAO+E,GAAG,CAACF,WAAX,CAAP,GAAiCE,GAAG,CAACF,WAArC,GAAmDhI,EAAE,CAACyF,GAAH,CAAOyC,GAAP,KAAeA,GAAG,CAACC,IAAnB,IAA2B,IAAhI;;AAEA,SAASvG,QAAT,EAAmBsC,aAAnB,EAAkCX,cAAlC,EAAkDR,cAAlD,EAAkEhB,aAAlE,EAAiF2F,UAAjF,EAA6FnG,WAA7F,EAA0GkD,eAA1G,EAA2H9C,UAA3H,EAAuIN,UAAvI,EAAmJI,WAAnJ","sourcesContent":["import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport * as React from 'react';\nimport { forwardRef, useRef, useCallback, useEffect } from 'react';\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\nconst getAnimated = owner => owner && owner[$node];\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this.done = true;\n    this.durationProgress = 0;\n    this._value = _value;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]));\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, dep => addFluidObserver(dep, observer));\n\n      if (lastObserver) {\n        each(lastObserver.deps, dep => removeFluidObserver(dep, lastObserver));\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer = observerRef.current;\n      each(observer.deps, dep => removeFluidObserver(dep, observer));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return React.createElement(Component, _extends({}, usedProps, {\n      ref: ref\n    }));\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _extends({}, props, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = (components, {\n  applyAnimatedValues: _applyAnimatedValues = () => false,\n  createAnimatedStyle: _createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps: _getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues: _applyAnimatedValues,\n    createAnimatedStyle: _createAnimatedStyle,\n    getComponentProps: _getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };\n"]},"metadata":{},"sourceType":"module"}