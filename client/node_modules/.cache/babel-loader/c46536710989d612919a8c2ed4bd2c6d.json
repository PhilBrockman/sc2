{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  attack: {\n    value: 0,\n    src: \"/attack.png\"\n  },\n  armor: {\n    value: 0,\n    src: \"/armor.png\"\n  },\n  shields: {\n    value: 0,\n    src: \"/shield.png\"\n  },\n  value: 4\n};\nexport const upgradeSlice = createSlice({\n  name: 'upgrade',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: state => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.attack.value += 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action) => {\n      console.log('state', state);\n      console.log('action', action);\n      console.log('kind', kind);\n      state[kind].value += action.payload;\n    }\n  }\n});\nexport const {\n  increment,\n  incrementByAmount\n} = upgradeSlice.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n\nexport const selectAttack = state => {\n  return state.upgrade.attack.value;\n};\nexport default upgradeSlice.reducer;","map":{"version":3,"sources":["/Users/philbrockman/coding/sc2/src/features/upgrade/upgradeSlice.js"],"names":["createSlice","initialState","attack","value","src","armor","shields","upgradeSlice","name","reducers","increment","state","incrementByAmount","action","console","log","kind","payload","actions","selectAttack","upgrade","reducer"],"mappings":"AAAA,SAASA,WAAT,QAA4B,kBAA5B;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,MAAM,EAAE;AACNC,IAAAA,KAAK,EAAE,CADD;AAENC,IAAAA,GAAG,EAAE;AAFC,GADW;AAKnBC,EAAAA,KAAK,EAAE;AACLF,IAAAA,KAAK,EAAE,CADF;AAELC,IAAAA,GAAG,EAAE;AAFA,GALY;AASnBE,EAAAA,OAAO,EAAE;AACPH,IAAAA,KAAK,EAAE,CADA;AAEPC,IAAAA,GAAG,EAAE;AAFE,GATU;AAanBD,EAAAA,KAAK,EAAE;AAbY,CAArB;AAgBA,OAAO,MAAMI,YAAY,GAAGP,WAAW,CAAC;AACtCQ,EAAAA,IAAI,EAAE,SADgC;AAEtCP,EAAAA,YAFsC;AAGtC;AACAQ,EAAAA,QAAQ,EAAE;AACRC,IAAAA,SAAS,EAAGC,KAAD,IAAW;AACpB;AACA;AACA;AACA;AACAA,MAAAA,KAAK,CAACT,MAAN,CAAaC,KAAb,IAAsB,CAAtB;AACD,KAPO;AAQR;AACAS,IAAAA,iBAAiB,EAAE,CAACD,KAAD,EAAQE,MAAR,KAAmB;AACpCC,MAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBJ,KAArB;AACAG,MAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EAAsBF,MAAtB;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAoBC,IAApB;AACAL,MAAAA,KAAK,CAACK,IAAD,CAAL,CAAYb,KAAZ,IAAqBU,MAAM,CAACI,OAA5B;AACD;AAdO;AAJ4B,CAAD,CAAhC;AAsBP,OAAO,MAAM;AAAEP,EAAAA,SAAF;AAAaE,EAAAA;AAAb,IAAmCL,YAAY,CAACW,OAAtD,C,CAEP;AACA;AACA;;AAEA,OAAO,MAAMC,YAAY,GAAIR,KAAD,IAAW;AACrC,SAAOA,KAAK,CAACS,OAAN,CAAclB,MAAd,CAAqBC,KAA5B;AACD,CAFM;AAIP,eAAeI,YAAY,CAACc,OAA5B","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  attack: {\n    value: 0,\n    src: \"/attack.png\",\n  }, \n  armor: {\n    value: 0,\n    src: \"/armor.png\",\n  },\n  shields: {\n    value: 0,\n    src: \"/shield.png\",\n  },\n  value: 4\n};\n\nexport const upgradeSlice = createSlice({\n  name: 'upgrade',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.attack.value += 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action) => {\n      console.log('state', state)\n      console.log('action', action)\n      console.log('kind', kind)\n      state[kind].value += action.payload;\n    },\n  },\n});\n\nexport const { increment, incrementByAmount } = upgradeSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n\nexport const selectAttack = (state) => {\n  return state.upgrade.attack.value;\n};\n\nexport default upgradeSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}