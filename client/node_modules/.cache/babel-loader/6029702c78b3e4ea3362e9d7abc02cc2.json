{"ast":null,"code":"// d = Damage(unit, defender, attack, attackResearch, armorResearch, shieldsResearch)\n// Damage.oneStep(unit, defender)\nexport class Damage {\n  constructor(attacker, _defender, attackIndex, research, guardian = 0) {\n    this.totalDamage = () => {\n      const def = this.def;\n      const att = this.att;\n\n      if (def.base.shields > 0 && this.damageInflicted(att, def) > def.base.shields + this.armorDefense(def)) {\n        return this.damageInflicted(att, def) - this.armorDefense(def);\n      } else {\n        return this.damageInflicted(att, def);\n      }\n    };\n\n    this.eliminate = () => {\n      let newValues = this.oneShot();\n\n      if (!newValues) {\n        return 0;\n      }\n\n      let count = 1;\n\n      while (((_newValues = newValues) === null || _newValues === void 0 ? void 0 : _newValues.health) > 0) {\n        var _newValues;\n\n        count++;\n\n        if (newValues) {\n          const defender = { ...this.def,\n            base: { ...this.def.base,\n              health: newValues.health,\n              shields: newValues.shields\n            }\n          };\n          const d = new Damage(this.att, JSON.parse(JSON.stringify(defender)), this.attackIndex, [this.research.attack, this.research.shields, this.research.armor]);\n          newValues = d.oneShot();\n        }\n      }\n\n      return count;\n    };\n\n    this.oneShot = (faked = true) => {\n      var _att;\n\n      let att;\n      let def;\n\n      if (faked) {\n        att = JSON.parse(JSON.stringify(this.att));\n        def = JSON.parse(JSON.stringify(this.def));\n      } else {\n        att = this.att;\n        def = this.def;\n      }\n\n      let results = null;\n      let log;\n\n      if (((_att = att) === null || _att === void 0 ? void 0 : _att.attacks[this.attackIndex]) === undefined || !def) {\n        return \"ðŸ‘€\";\n      }\n\n      if (!canAttackTargetDefender(att.attacks[this.attackIndex], def)) {\n        return \"can't shoot\";\n      }\n\n      if (def.base.health > 0) {\n        let damageSum = 0;\n\n        for (var i = 0; i < att.attacks[this.attackIndex].repeats; i++) {\n          var _def$base;\n\n          const d = new Damage(att, JSON.parse(JSON.stringify(def)), this.attackIndex, [this.research.attack, this.research.shields, this.research.armor]);\n          let damage = d.totalDamage();\n\n          if (((_def$base = def.base) === null || _def$base === void 0 ? void 0 : _def$base.shields) > 0) {\n            if (damage <= def.base.shields) {\n              def.base.shields -= damage;\n              log = `${damage} to shields. (${def.base.shields} remaining)`;\n            } else {\n              def.base.shields = 0;\n              def.base.health -= damage - def.base.shields;\n              log = `${damage} has overloaded shields. (${def.base.health} health remaining)`;\n            }\n          } else {\n            def.base.health -= damage;\n            log = `${damage} damage. (${def.base.health} HP)`;\n          }\n\n          damageSum += damage;\n\n          if (def.base.health < 0) {\n            const overkill = (100 * -def.base.health / damageSum).toFixed(1);\n            log += ` (${overkill}% attack wasted)`;\n          }\n\n          console.log('log', log);\n          results = {\n            health: def.base.health,\n            shields: def.base.shields,\n            totalDamage: damageSum\n          };\n        }\n      }\n\n      return results;\n    };\n\n    const [attackResearch, shieldsResearch, armorResearch] = research;\n    this.research = {\n      attack: attackResearch,\n      armor: armorResearch,\n      shields: shieldsResearch\n    };\n    this.att = JSON.parse(JSON.stringify(attacker));\n    this.def = JSON.parse(JSON.stringify(_defender));\n    this.attackIndex = attackIndex;\n    let Spell = 1;\n    let Hallucinated = 1;\n    let Corrupted = 1;\n    let Hardened = 900;\n    let Prismatic = 1;\n\n    this.bonusDamage = () => {\n      return this.att.attacks[this.attackIndex].bonuses.filter(bonus => this.def.types.includes(bonus.to)).reduce((total, amount) => {\n        return total + amount.baseDamage + amount.researchBonus * this.research.attack;\n      }, 0);\n    };\n\n    this.damageDealt = () => {\n      var _this$att;\n\n      const attack = (_this$att = this.att) === null || _this$att === void 0 ? void 0 : _this$att.attacks[this.attackIndex];\n\n      if (this.att && this.def && attack) {\n        return attack.baseDamage + this.research.attack * attack.researchBonus + this.bonusDamage();\n      } else {\n        return \"not enough info\";\n      }\n    };\n\n    this.armorDefense = () => {\n      return this.def.base.armor + this.research.armor;\n    };\n\n    this.defenseAvailable = () => {\n      var _this$def$base;\n\n      if (((_this$def$base = this.def.base) === null || _this$def$base === void 0 ? void 0 : _this$def$base.shields) > 0) {\n        return this.research.shields;\n      } else {\n        return this.armorDefense(this.def);\n      }\n    };\n\n    this.defenseApplied = () => {\n      return this.defenseAvailable() * Spell * (2 - Hallucinated);\n    };\n\n    this.damageReceived = () => {\n      return this.damageDealt() * Corrupted * Hallucinated * Prismatic - this.defenseApplied();\n    };\n\n    this.damageCapped = (att, def) => {\n      return Math.min(this.damageReceived(att, def), Hardened * Corrupted * Hallucinated + 900 * (1 - Spell));\n    };\n\n    this.damageInflicted = (att, def) => {\n      return Math.max(.5, this.damageCapped(att, def) - guardian);\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/philbrockman/coding/sc2/client/src/components/Attacker/Damage.js"],"names":["Damage","constructor","attacker","defender","attackIndex","research","guardian","totalDamage","def","att","base","shields","damageInflicted","armorDefense","eliminate","newValues","oneShot","count","health","d","JSON","parse","stringify","attack","armor","faked","results","log","attacks","undefined","canAttackTargetDefender","damageSum","i","repeats","damage","overkill","toFixed","console","attackResearch","shieldsResearch","armorResearch","Spell","Hallucinated","Corrupted","Hardened","Prismatic","bonusDamage","bonuses","filter","bonus","types","includes","to","reduce","total","amount","baseDamage","researchBonus","damageDealt","defenseAvailable","defenseApplied","damageReceived","damageCapped","Math","min","max"],"mappings":"AACA;AACA;AACA,OAAO,MAAMA,MAAN,CAAY;AACjBC,EAAAA,WAAW,CAAEC,QAAF,EAAYC,SAAZ,EAAsBC,WAAtB,EAAmCC,QAAnC,EAA6CC,QAAQ,GAAC,CAAtD,EAAyD;AAAA,SA2EtEC,WA3EsE,GA2ExD,MAAM;AAClB,YAAMC,GAAG,GAAG,KAAKA,GAAjB;AACA,YAAMC,GAAG,GAAG,KAAKA,GAAjB;;AAEA,UAAGD,GAAG,CAACE,IAAJ,CAASC,OAAT,GAAmB,CAAnB,IAAwB,KAAKC,eAAL,CAAqBH,GAArB,EAA0BD,GAA1B,IAAiCA,GAAG,CAACE,IAAJ,CAASC,OAAT,GAAmB,KAAKE,YAAL,CAAkBL,GAAlB,CAA/E,EAAsG;AACpG,eAAO,KAAKI,eAAL,CAAqBH,GAArB,EAA0BD,GAA1B,IAA+B,KAAKK,YAAL,CAAkBL,GAAlB,CAAtC;AACD,OAFD,MAEO;AACL,eAAO,KAAKI,eAAL,CAAqBH,GAArB,EAA0BD,GAA1B,CAAP;AACD;AACF,KApFqE;;AAAA,SAuFtEM,SAvFsE,GAuF1D,MAAM;AAChB,UAAIC,SAAS,GAAG,KAAKC,OAAL,EAAhB;;AACA,UAAG,CAACD,SAAJ,EAAc;AAAC,eAAO,CAAP;AAAS;;AACxB,UAAIE,KAAK,GAAG,CAAZ;;AACA,aAAM,eAAAF,SAAS,UAAT,gDAAWG,MAAX,IAAoB,CAA1B,EAA4B;AAAA;;AAC1BD,QAAAA,KAAK;;AAEH,YAAGF,SAAH,EAAa;AACX,gBAAMZ,QAAQ,GAAG,EACf,GAAG,KAAKK,GADO;AAEfE,YAAAA,IAAI,EAAE,EACJ,GAAG,KAAKF,GAAL,CAASE,IADR;AAEJQ,cAAAA,MAAM,EAAEH,SAAS,CAACG,MAFd;AAGJP,cAAAA,OAAO,EAAEI,SAAS,CAACJ;AAHf;AAFS,WAAjB;AAQA,gBAAMQ,CAAC,GAAI,IAAInB,MAAJ,CAAW,KAAKS,GAAhB,EACTW,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,QAAf,CAAX,CADS,EAC6B,KAAKC,WADlC,EAET,CAAE,KAAKC,QAAL,CAAckB,MAAhB,EAAwB,KAAKlB,QAAL,CAAcM,OAAtC,EAA+C,KAAKN,QAAL,CAAcmB,KAA7D,CAFS,CAAX;AAGAT,UAAAA,SAAS,GAAEI,CAAC,CAACH,OAAF,EAAX;AACD;AAEF;;AACD,aAAOC,KAAP;AACH,KA/GqE;;AAAA,SAkHtED,OAlHsE,GAkH5D,CAACS,KAAK,GAAC,IAAP,KAAgB;AAAA;;AACxB,UAAIhB,GAAJ;AAAS,UAAID,GAAJ;;AACT,UAAGiB,KAAH,EAAS;AACPhB,QAAAA,GAAG,GAAGW,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAe,KAAKb,GAApB,CAAX,CAAN;AACAD,QAAAA,GAAG,GAAGY,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAe,KAAKd,GAApB,CAAX,CAAN;AACD,OAHD,MAGO;AACLC,QAAAA,GAAG,GAAG,KAAKA,GAAX;AACAD,QAAAA,GAAG,GAAG,KAAKA,GAAX;AACD;;AAED,UAAIkB,OAAO,GAAG,IAAd;AACA,UAAIC,GAAJ;;AAEA,UAAG,SAAAlB,GAAG,UAAH,oCAAKmB,OAAL,CAAa,KAAKxB,WAAlB,OAAmCyB,SAAnC,IAAgD,CAACrB,GAApD,EAAwD;AACtD,eAAO,IAAP;AACD;;AAAC,UAAG,CAACsB,uBAAuB,CAACrB,GAAG,CAACmB,OAAJ,CAAY,KAAKxB,WAAjB,CAAD,EAAgCI,GAAhC,CAA3B,EAAgE;AAChE,eAAO,aAAP;AACD;;AACD,UAAGA,GAAG,CAACE,IAAJ,CAASQ,MAAT,GAAkB,CAArB,EAAuB;AACrB,YAAIa,SAAS,GAAC,CAAd;;AAEA,aAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGvB,GAAG,CAACmB,OAAJ,CAAY,KAAKxB,WAAjB,EAA8B6B,OAAjD,EAA0DD,CAAC,EAA3D,EAA8D;AAAA;;AAC5D,gBAAMb,CAAC,GAAI,IAAInB,MAAJ,CAAWS,GAAX,EACTW,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAed,GAAf,CAAX,CADS,EACwB,KAAKJ,WAD7B,EAET,CAAE,KAAKC,QAAL,CAAckB,MAAhB,EAAwB,KAAKlB,QAAL,CAAcM,OAAtC,EAA+C,KAAKN,QAAL,CAAcmB,KAA7D,CAFS,CAAX;AAGA,cAAIU,MAAM,GAAGf,CAAC,CAACZ,WAAF,EAAb;;AACA,cAAG,cAAAC,GAAG,CAACE,IAAJ,wDAAUC,OAAV,IAAoB,CAAvB,EAAyB;AACvB,gBAAGuB,MAAM,IAAI1B,GAAG,CAACE,IAAJ,CAASC,OAAtB,EAA8B;AAC5BH,cAAAA,GAAG,CAACE,IAAJ,CAASC,OAAT,IAAoBuB,MAApB;AACAP,cAAAA,GAAG,GAAI,GAAEO,MAAO,iBAAgB1B,GAAG,CAACE,IAAJ,CAASC,OAAQ,aAAjD;AACD,aAHD,MAGO;AACLH,cAAAA,GAAG,CAACE,IAAJ,CAASC,OAAT,GAAmB,CAAnB;AACAH,cAAAA,GAAG,CAACE,IAAJ,CAASQ,MAAT,IAAmBgB,MAAM,GAAG1B,GAAG,CAACE,IAAJ,CAASC,OAArC;AACAgB,cAAAA,GAAG,GAAI,GAAEO,MAAO,6BAA4B1B,GAAG,CAACE,IAAJ,CAASQ,MAAO,oBAA5D;AACD;AACF,WATD,MASO;AACLV,YAAAA,GAAG,CAACE,IAAJ,CAASQ,MAAT,IAAmBgB,MAAnB;AACAP,YAAAA,GAAG,GAAI,GAAEO,MAAO,aAAY1B,GAAG,CAACE,IAAJ,CAASQ,MAAO,MAA5C;AACD;;AACDa,UAAAA,SAAS,IAAIG,MAAb;;AACA,cAAG1B,GAAG,CAACE,IAAJ,CAASQ,MAAT,GAAkB,CAArB,EAAuB;AACrB,kBAAMiB,QAAQ,GAAG,CAAC,MAAI,CAAC3B,GAAG,CAACE,IAAJ,CAASQ,MAAd,GAAqBa,SAAtB,EAAiCK,OAAjC,CAAyC,CAAzC,CAAjB;AACAT,YAAAA,GAAG,IAAK,KAAIQ,QAAS,kBAArB;AACD;;AACDE,UAAAA,OAAO,CAACV,GAAR,CAAY,KAAZ,EAAmBA,GAAnB;AACAD,UAAAA,OAAO,GAAI;AAACR,YAAAA,MAAM,EAAEV,GAAG,CAACE,IAAJ,CAASQ,MAAlB;AAA0BP,YAAAA,OAAO,EAAEH,GAAG,CAACE,IAAJ,CAASC,OAA5C;AAAqDJ,YAAAA,WAAW,EAAEwB;AAAlE,WAAX;AACD;AACF;;AAED,aAAOL,OAAP;AACD,KApKqE;;AACpE,UAAM,CAACY,cAAD,EAAiBC,eAAjB,EAAkCC,aAAlC,IAAmDnC,QAAzD;AACA,SAAKA,QAAL,GAAgB;AACdkB,MAAAA,MAAM,EAAEe,cADM;AAEdd,MAAAA,KAAK,EAAEgB,aAFO;AAGd7B,MAAAA,OAAO,EAAE4B;AAHK,KAAhB;AAMA,SAAK9B,GAAL,GAAWW,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAepB,QAAf,CAAX,CAAX;AACA,SAAKM,GAAL,GAAWY,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAenB,SAAf,CAAX,CAAX;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AAEA,QAAIqC,KAAK,GAAG,CAAZ;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,QAAQ,GAAG,GAAf;AACA,QAAIC,SAAS,GAAG,CAAhB;;AAEA,SAAKC,WAAL,GAAmB,MAAM;AACvB,aAAO,KAAKrC,GAAL,CAASmB,OAAT,CAAiB,KAAKxB,WAAtB,EAAmC2C,OAAnC,CAA2CC,MAA3C,CAAkDC,KAAK,IAAI,KAAKzC,GAAL,CAAS0C,KAAT,CAAeC,QAAf,CAAwBF,KAAK,CAACG,EAA9B,CAA3D,EAA8FC,MAA9F,CAAqG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC7H,eAAOD,KAAK,GAACC,MAAM,CAACC,UAAb,GAAwBD,MAAM,CAACE,aAAP,GAAqB,KAAKpD,QAAL,CAAckB,MAAlE;AACD,OAFM,EAEJ,CAFI,CAAP;AAGD,KAJD;;AAMA,SAAKmC,WAAL,GAAmB,MAAM;AAAA;;AACvB,YAAMnC,MAAM,gBAAG,KAAKd,GAAR,8CAAG,UAAUmB,OAAV,CAAkB,KAAKxB,WAAvB,CAAf;;AACA,UAAG,KAAKK,GAAL,IAAY,KAAKD,GAAjB,IAAwBe,MAA3B,EAAkC;AAChC,eACEA,MAAM,CAACiC,UAAP,GACA,KAAKnD,QAAL,CAAckB,MAAd,GAAqBA,MAAM,CAACkC,aAD5B,GAEA,KAAKX,WAAL,EAHF;AAKD,OAND,MAMO;AACL,eAAO,iBAAP;AACD;AACF,KAXD;;AAaA,SAAKjC,YAAL,GAAoB,MAAM;AACxB,aAAO,KAAKL,GAAL,CAASE,IAAT,CAAcc,KAAd,GAAsB,KAAKnB,QAAL,CAAcmB,KAA3C;AACD,KAFD;;AAIA,SAAKmC,gBAAL,GAAwB,MAAM;AAAA;;AAC5B,UAAG,wBAAKnD,GAAL,CAASE,IAAT,kEAAeC,OAAf,IAAyB,CAA5B,EAA8B;AAC5B,eAAO,KAAKN,QAAL,CAAcM,OAArB;AACD,OAFD,MAEO;AACL,eAAO,KAAKE,YAAL,CAAkB,KAAKL,GAAvB,CAAP;AACD;AACF,KAND;;AAQA,SAAKoD,cAAL,GAAsB,MAAM;AAC1B,aAAO,KAAKD,gBAAL,KAAwBlB,KAAxB,IAA+B,IAAEC,YAAjC,CAAP;AACD,KAFD;;AAIF,SAAKmB,cAAL,GAAsB,MAAM;AACxB,aAAO,KAAKH,WAAL,KAAmBf,SAAnB,GAA6BD,YAA7B,GAA0CG,SAA1C,GAAsD,KAAKe,cAAL,EAA7D;AACD,KAFH;;AAKE,SAAKE,YAAL,GAAoB,CAACrD,GAAD,EAAMD,GAAN,KAAc;AAChC,aAAOuD,IAAI,CAACC,GAAL,CACL,KAAKH,cAAL,CAAoBpD,GAApB,EAAyBD,GAAzB,CADK,EAELoC,QAAQ,GAACD,SAAT,GAAmBD,YAAnB,GAAgC,OAAK,IAAED,KAAP,CAF3B,CAAP;AAID,KALD;;AAOA,SAAK7B,eAAL,GAAuB,CAACH,GAAD,EAAMD,GAAN,KAAc;AACnC,aAAOuD,IAAI,CAACE,GAAL,CACL,EADK,EAEL,KAAKH,YAAL,CAAkBrD,GAAlB,EAAuBD,GAAvB,IAA8BF,QAFzB,CAAP;AAID,KALD;AAQD;;AA1EkB","sourcesContent":["\n// d = Damage(unit, defender, attack, attackResearch, armorResearch, shieldsResearch)\n// Damage.oneStep(unit, defender)\nexport class Damage{\n  constructor( attacker, defender, attackIndex, research, guardian=0) {\n  const [attackResearch, shieldsResearch, armorResearch] = research\n  this.research = {\n    attack: attackResearch,\n    armor: armorResearch,\n    shields: shieldsResearch\n  }\n\n  this.att = JSON.parse(JSON.stringify(attacker));\n  this.def = JSON.parse(JSON.stringify(defender));\n  this.attackIndex = attackIndex\n\n  let Spell = 1\n  let Hallucinated = 1\n  let Corrupted = 1\n  let Hardened = 900\n  let Prismatic = 1\n\n  this.bonusDamage = () => {\n    return this.att.attacks[this.attackIndex].bonuses.filter(bonus => this.def.types.includes(bonus.to)).reduce((total, amount) => {\n      return total+amount.baseDamage+amount.researchBonus*this.research.attack\n    }, 0)\n  }\n\n  this.damageDealt = () => {\n    const attack = this.att?.attacks[this.attackIndex]\n    if(this.att && this.def && attack){\n      return (\n        attack.baseDamage +\n        this.research.attack*attack.researchBonus +\n        this.bonusDamage()\n      )  \n    } else {\n      return \"not enough info\"\n    }\n  }\n\n  this.armorDefense = () => {\n    return this.def.base.armor + this.research.armor\n  }\n\n  this.defenseAvailable = () => {\n    if(this.def.base?.shields > 0){\n      return this.research.shields\n    } else {\n      return this.armorDefense(this.def)\n    }\n  }\n\n  this.defenseApplied = () => {\n    return this.defenseAvailable()*Spell*(2-Hallucinated)\n  }\n\nthis.damageReceived = () => {\n    return this.damageDealt()*Corrupted*Hallucinated*Prismatic - this.defenseApplied();\n  }\n\n\n  this.damageCapped = (att, def) => {\n    return Math.min(\n      this.damageReceived(att, def),\n      Hardened*Corrupted*Hallucinated+900*(1-Spell)\n    );\n  }\n\n  this.damageInflicted = (att, def) => {\n    return Math.max(\n      .5,\n      this.damageCapped(att, def) - guardian\n    );\n  }\n\n\n}\n\ntotalDamage = () => {\n  const def = this.def\n  const att = this.att\n\n  if(def.base.shields > 0 && this.damageInflicted(att, def) > def.base.shields + this.armorDefense(def)){\n    return this.damageInflicted(att, def)-this.armorDefense(def)\n  } else {\n    return this.damageInflicted(att, def)\n  }\n}\n\n\neliminate = () => {\n  let newValues = this.oneShot();\n  if(!newValues){return 0}\n  let count = 1;\n  while(newValues?.health > 0){\n    count++;\n\n      if(newValues){\n        const defender = {\n          ...this.def,\n          base: {\n            ...this.def.base,\n            health: newValues.health,\n            shields: newValues.shields,\n          }\n        }\n        const d =  new Damage(this.att,\n          JSON.parse(JSON.stringify(defender)), this.attackIndex, \n          [ this.research.attack, this.research.shields, this.research.armor])\n        newValues= d.oneShot()\n      }\n      \n    }\n    return count;\n}\n\n\noneShot = (faked=true) => {\n  let att; let def;\n  if(faked){\n    att = JSON.parse(JSON.stringify(this.att));\n    def = JSON.parse(JSON.stringify(this.def));\n  } else {\n    att = this.att\n    def = this.def\n  }\n\n  let results = null\n  let log;\n\n  if(att?.attacks[this.attackIndex] === undefined || !def){\n    return \"ðŸ‘€\"\n  } if(!canAttackTargetDefender(att.attacks[this.attackIndex], def)){\n    return \"can't shoot\"\n  }\n  if(def.base.health > 0){\n    let damageSum=0;\n\n    for(var i = 0; i < att.attacks[this.attackIndex].repeats; i++){\n      const d =  new Damage(att,\n        JSON.parse(JSON.stringify(def)), this.attackIndex, \n        [ this.research.attack, this.research.shields, this.research.armor])\n      let damage = d.totalDamage();\n      if(def.base?.shields > 0){\n        if(damage <= def.base.shields){\n          def.base.shields -= damage\n          log = `${damage} to shields. (${def.base.shields} remaining)`\n        } else {\n          def.base.shields = 0;\n          def.base.health -= damage - def.base.shields;\n          log = `${damage} has overloaded shields. (${def.base.health} health remaining)`\n        }\n      } else {\n        def.base.health -= damage;\n        log = `${damage} damage. (${def.base.health} HP)`\n      }\n      damageSum += damage;\n      if(def.base.health < 0){\n        const overkill = (100*-def.base.health/damageSum).toFixed(1)\n        log += ` (${overkill}% attack wasted)`\n      }\n      console.log('log', log)\n      results = ({health: def.base.health, shields: def.base.shields, totalDamage: damageSum})\n    }\n  }\n\n  return results\n}\n}\n"]},"metadata":{},"sourceType":"module"}